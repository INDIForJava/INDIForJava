%{include|source-content=<div id\="apt-box">}

Example Tutorrial

 In this page we describe how to write a very simple Driver using the INDI for Java libraries. It is assumed that you have some knowledge about the INDI Library 
and some Java programming experience. If you find any errors or think that any point should be clarified, please do not hesitate to contact me at zerjio AT zerjio.com.

*Initial Configuration 

 Maven is recommendet, but not a requirement. The creation of a maven project is out of scope, but very simple (see {{{http://maven.apache.org/guides/getting-started/maven-in-five-minutes.html}Maven in 5 Minutes}}).
Now take the pom from the examples project and adapt it to your needs:

%{include|source=pom.xml}

 Do this by changing the atrifact id and version information, and adding the extra dependencies you need. We do not recomment any
specific IDE, your faforite is probably the best choice. 

 Because of the deployment to central, no downloads are nessesary. The development tools will get what they need themself.
 
*Example Driver Description

 We are going to develop a very simple INDI Driver called INDIDriverExample. It will have just three different properties:

 [[1]] The first one will consist on the usual CONNECTION property (a Switch one). As you will see, providing this standard Property is a quite easy with the INDI for Java Driver library.

 [[2]] The second one will consist on a Switch property called sendImage with just one element. This will allow to use it just as a trigger to request an image.

 [[3]] The third one will consist on a BLOB property called image which will contain some image binary data and that will be sent to the client once it is requested (using the sendImage property.

 []
  
*Creating the INDI Driver 

 Every INDI Driver developed with the INDI for Java Driver is a class that extends (directly or indirectly )the laazotea.indi.driver.INDIDriver class:
 
%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#declaration|source-is-template=true|projectVersion=1.0}

 Also note that the class implements INDIConnectionHandler. This will allow to easily define and use the standard CONNECTION Property. In fact, once the Driver is set to implement the methods in INDIConnectionHandler it automatically adds the Property and its elements, requiring no additional programming (apart from the specific connection and disconnetion code that we will show in the following).

 As the INDIDriver class is abstract, we have to implement several methods. One of the most important ones is the getName() method:

%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#getName|source-is-template=true|projectVersion=1.0}

 Note that the INDIDriver constructor needs an INDIConnection from where the messages will be sent and received. That is why we use

%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#constructor|source-is-template=true|projectVersion=1.0} 

 as the first action in the constructor.

 There are two API's to define new properties. A declaritive api that uses injection and a programmatic that uses the builder pattern, both can be used mixed as you need.
 
**Injecting Properties

 For most drivers injecting properties is the simplest way to define properties. Just define the field for the property and it's element and add the describing Annotation.
 
%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#fieldsInject|source-is-template=true|projectVersion=1.0}

 The annotation defines the default values, so just define the attributes that have non default values. Elements will be added to the property that was defined before it (order of the fields in the Class).
If you want to specify a specific property (form the superclass for example) just specify the name in the peropery attribue.

 Fields with anntations are initialized automaticaly during the construction.
 
**Programming Properties

 For some properties need to be made programaticaly because the names or the elements are only know at runtime and can not be declared. For these properties normal fields are created:
 
%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#fieldsClasic|source-is-template=true|projectVersion=1.0}

 In the constructor of the driver the fields are initialized:
 
%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#initClasic|source-is-template=true|projectVersion=1.0}
 
 You see almoust the same notations as with the injection, just with the use of the builder design pattern. The defaults are in both cases the same, so do
not set attributes that have default values.
 
*Connecting the Driver 

 Now is time to add the created Properties to the Driver. We will do this when the Client ask the device to be connected (via the CONNECTION Property). As we previously mentioned our driver implements INDIConnectionHandler which is composed of the following methods:

%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#connection|source-is-template=true|projectVersion=1.0}

 Note that when the Client asks for the disconnection of the Driver the properties will be removed.  

*Dealing with Changes in the Properties 

 We are almost finishing our example. In fact, the only thing to do is to parse the Client requests to change the Property values. To do so we must implement event handlers (one for each kind of Property except from Light ones that cannot be changed at the client side):
  
%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#eventHandler|source-is-template=true|projectVersion=1.0}

 As soon as a client changes the value of the property the event handler will be called. It is recommented that you do not implement big methods in these anonymous classes, please redirect
it to a clearly named method in the driver class (As done in the example).

**Doing some action

 As a reaction on the change of our sent property our action:
 
%{include|source=org.indilib.i4j.driver.examples.INDIDriverExample|snippet=#action|source-is-template=true|projectVersion=1.0}

 The function loadImageFromFile() just loads a image (the one to be sent) from the hard disk into the BLOB Property.
 
*Running and Testing the Driver 

 To realy test the driver just put it in the lib directory of the all in one package and start the interactive server.
The "c" command with your driver class as a parameter will start up your driver, take any indi client to connect to the server to test it.
 
*Unit Testing the Driver 

 To test the drivers there is a junit runner that makes testing an easy job. If you have ideas to make the tests even more easy please send us this sugestion!
Just create a normal junit test and give it a indi test runner.

%{include|source=org.indilib.i4j.driver.examples.test.TestINDIDriverExample|snippet=#runWith|source-is-template=true|projectVersion=1.0}

 Now we have to define the fields for the driver and the testclient:
 
%{include|source=org.indilib.i4j.driver.examples.test.TestINDIDriverExample|snippet=#fields|source-is-template=true|projectVersion=1.0}
 
 Ok, that's it already. We can start testing, in the first test we will connect the driver than press the send switch and check if the image was send.
The test is rather straightforward so we leave it to you to understand it.

%{include|source=org.indilib.i4j.driver.examples.test.TestINDIDriverExample|snippet=#test|source-is-template=true|projectVersion=1.0}
 
 Note that in our case nothing in the driver itself is tested, but you can go as far as you want. For some cases it would be useful to create a test subclass of your driver to have better access to some things and to mock around some of the internals.
 
*Complete Source Code and Additional Required Files 

 the example drivers are included in the distribution includeing the sources.

%{include|source-content=</div>}